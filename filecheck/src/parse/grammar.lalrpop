use std::borrow::Cow;

use either::Either;
use either::Either::*;

use crate::common::{Spanned, Span, Symbol, SourceId, symbols};
use crate::ast::*;
use crate::expr::*;
use crate::parse::{LexerError, Token, ParserError, ParseError};

grammar<'input, 'parser>(source_id: SourceId, _source: &'input str);

// LEXER
// ================================================================================================

extern {
    type Error = ParserError;
    type Location = usize;

    enum Token<'input> {
        LF => Token::Lf,
        ERROR => Token::Error(<LexerError>),
        COMMENT => Token::Comment(<std::borrow::Cow<'input, str>>),
        CHECK => Token::Check(<Check>),
        raw => Token::Raw(<&'input str>),
        ident => Token::Ident(<&'input str>),
        number => Token::Num(<i128>),
        "[[" => Token::MatchStart,
        "]]" => Token::MatchEnd,
        "{{" => Token::RegexStart,
        "}}" => Token::RegexEnd,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "#" => Token::Hash,
        "$" => Token::Dollar,
        "%" => Token::Percent,
        "@" => Token::At,
        "," => Token::Comma,
        "." => Token::Dot,
        ":" => Token::Colon,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "=" => Token::Equal,
        "==" => Token::Equals,
        "LITERAL" => Token::Literal,
        "LINE" => Token::Line,
        "add" => Token::Add,
        "sub" => Token::Sub,
        "mul" => Token::Mul,
        "div" => Token::Div,
        "min" => Token::Min,
        "max" => Token::Max,

    }
}


// Comma-delimited with at least one element
#[inline]
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};


/// MATCH

pub Match: Match<'input> = {
    <l:@L> "[[" <name:LineVar> <expr:CaptureExprRest> "]]" <r:@R> => {
        match expr {
            Some(BinaryOpAndOperand { op, operand: rhs }) => {
                let span = span!(source_id, l, r);
                Match::Numeric {
                    span,
                    format: None,
                    capture: None,
                    constraint: Constraint::Eq,
                    expr: Some(Expr::Binary {
                        span,
                        op,
                        lhs: Box::new(Expr::Var(name)),
                        rhs,
                    }),
                }
            }
            None => Match::Substitution { span: span!(source_id, l, r), name, pattern: None },
        }
    },

    <l:@L> "[[" <name:PatternVar> "]]" <r:@R> => Match::Substitution { span: span!(source_id, l, r), name, pattern: None },

    <l:@L> "[[" <name:MaybeGlobalVar> ":" <pattern:String>  "]]" <r:@R> => Match::Substitution { span: span!(source_id, l, r), name, pattern: Some(pattern.map(Cow::Borrowed)) },

    <l:@L> "[[" "#" <format:(<NumberFormat> ",")?> <capture:CaptureNumericOrExpr?> "]]" <r:@R> => {
        let span = span!(source_id, l, r);
        match capture {
            None => Match::Numeric {
                span,
                format,
                capture: None,
                constraint: Constraint::Eq,
                expr: None,
            },
            Some(CaptureNumericOrExpr::Capture(CaptureNumeric { name, constraint, expr })) => Match::Numeric {
                span,
                format,
                capture: name,
                constraint,
                expr,
            },
            Some(CaptureNumericOrExpr::Expr(expr)) => Match::Numeric {
                span,
                format,
                capture: None,
                constraint: Constraint::Eq,
                expr: Some(expr),
            },
        }
    },
}

CaptureNumericOrExpr: CaptureNumericOrExpr = {
    <l:@L> <var:PatternOrLineVar> <ty:EitherCaptureOrExpr> => {
        match ty {
            Left(None) => CaptureNumericOrExpr::Capture(CaptureNumeric {
                name: Some(var),
                constraint: Constraint::Eq,
                expr: None
            }),
            Left(Some(constraint)) => CaptureNumericOrExpr::Capture(CaptureNumeric {
                name: Some(var),
                constraint: constraint.constraint,
                expr: Some(constraint.expr)
            }),
            Right(None) => CaptureNumericOrExpr::Expr(Expr::Var(var)),
            Right(Some(BinaryOpAndOperand { op, operand: rhs })) => {
                let rhs_span = rhs.span();
                let end = rhs_span.end().to_usize();
                CaptureNumericOrExpr::Expr(Expr::Binary {
                    span: span!(source_id, l, end),
                    op,
                    lhs: Box::new(Expr::Var(var)),
                    rhs,
                })
            }
        }
    },

    "==" <expr:Expr> => {
        CaptureNumericOrExpr::Capture(CaptureNumeric {
            name: None,
            constraint: Constraint::Eq,
            expr: Some(expr)
        })
    },

    Builtin => CaptureNumericOrExpr::Expr(<>),

    <l:@L> "(" <lhs:Expr> ")" <rhs:CaptureExprRest> <r:@R> => {
        match rhs {
            None => CaptureNumericOrExpr::Expr(lhs),
            Some(BinaryOpAndOperand { op, operand }) => {
                CaptureNumericOrExpr::Expr(
                    Expr::Binary {
                        span: span!(source_id, l, r),
                        op,
                        lhs: Box::new(lhs),
                        rhs: operand,
                    }
                )
            }
        }
    }
}

CaptureExprRest: Option<BinaryOpAndOperand> = {
    "+" <expr:Expr> => Some(BinaryOpAndOperand { op: BinaryOp::Add, operand: Box::new(expr) }),
    "-" <expr:Expr> => Some(BinaryOpAndOperand { op: BinaryOp::Sub, operand: Box::new(expr) }),
    => None,
}

EitherCaptureOrExpr: Either<Option<ConstraintExpr>, Option<BinaryOpAndOperand>> = {
    ":" <constraint:Constraint?> => Left(constraint),
    <CaptureExprRest> => Right(<>),
}

Constraint: ConstraintExpr = {
    "==" <expr:Expr> => ConstraintExpr { constraint: Constraint::Eq, expr },
    <expr:Expr> => ConstraintExpr { constraint: Constraint::Eq, expr },
}

/// VARIABLES

NumberFormat: NumberFormat = {
    <l:@L> "%" <require_prefix:RequirePrefix> <precision:("." <Precision>)?> <ty:FormatSpecifier> <r:@R> =>? {
        let precision = precision.unwrap_or(0);
        if require_prefix && matches!(ty, FormatSpecifier::Unsigned | FormatSpecifier::Signed) {
            return Err(ParseError::User {
                error: ParserError::from(ExprError::InvalidAlternateForm {
                    span: span!(source_id, l, r),
                }),
            });
        }
        Ok(match ty {
            FormatSpecifier::Unsigned => NumberFormat::Unsigned { precision },
            FormatSpecifier::Signed => NumberFormat::Signed { precision },
            FormatSpecifier::Hex(casing) => NumberFormat::Hex { require_prefix, precision, casing },
        })
    }
}

/// EXPRS

Expr: Expr = {
    <l:@L> <x:Expr> "+" <y:Subexpr> <r:@R> => Expr::Binary { span: span!(source_id, l, r), op: BinaryOp::Add, lhs: Box::new(x), rhs: Box::new(y) },
    <l:@L> <x:Expr> "-" <y:Subexpr> <r:@R> => Expr::Binary { span: span!(source_id, l, r), op: BinaryOp::Sub, lhs: Box::new(x), rhs: Box::new(y) },
    Subexpr,
}

Subexpr: Expr = {
    Builtin,
    Call,
    Term,
}

#[inline]
Builtin: Expr = {
    <l:@L> <op:BinaryOp> "(" <x:Expr> "," <y:Expr> ")" <r:@R> => Expr::Binary { span: span!(source_id, l, r), op, lhs: Box::new(x), rhs: Box::new(y) },
}

Call: Expr = {
    <l:@L> <callee:Callee> "(" <args:Comma<Expr>> ")" <r:@R> =>? {
        Expr::from_call(span!(source_id, l, r), callee, args)
            .map_err(|err| ParseError::User {
                error: ParserError::from(ExprError::from(err))
            })
    }
}

Term: Expr = {
    Num,
    <PatternOrLineVar> => Expr::Var(<>),
    "(" <Expr> ")" => <>,
}

BinaryOp: BinaryOp = {
    "add" => BinaryOp::Add,
    "sub" => BinaryOp::Sub,
    "mul" => BinaryOp::Mul,
    "div" => BinaryOp::Div,
    "min" => BinaryOp::Min,
    "max" => BinaryOp::Max,
}


/// ATOMS

PatternVar: VariableName = {
    GlobalVar,
    PseudoVar,
    Var,
}

PatternOrLineVar: VariableName = {
    PatternVar,
    LineVar,
}

GlobalVar: VariableName = {
    <l:@L> "$" <name:Ident> <r:@R> => VariableName::Global(Span::new(span!(source_id, l, r), name)),
}

MaybeGlobalVar: VariableName = {
    <l:@L> "$" <name:Ident> <r:@R> => VariableName::Global(Span::new(span!(source_id, l, r), name)),
    Var,
}

PseudoVar: VariableName = {
    <l:@L> "@" <name:Ident> <r:@R> => VariableName::Pseudo(Span::new(span!(source_id, l, r), name)),
}

LineVar: VariableName = {
    <l:@L> "@" "LINE" <r:@R> => VariableName::Pseudo(Span::new(span!(source_id, l, r), symbols::Line)),
}

Var: VariableName = {
    <l:@L> <name:Ident> <r:@R> => VariableName::User(Span::new(span!(source_id, l, r), name)),
}

Callee: Span<Symbol> = {
    <l:@L> <name:Ident> <r:@R> => Span::new(span!(source_id, l, r), name),
}

Num: Expr = {
    <l:@L> <negate:Negate> <n:number> <r:@R> =>? {
        let n = if negate { -n } else { n };
        Ok(Expr::Num(Number::new(span!(source_id, l, r), n)))
    },
    <error:ERROR> =>? Err(ParseError::User { error: ParserError::from(error) }),
}

Negate: bool = {
    "-" => true,
    => false,
}

RequirePrefix: bool = {
    "#" => true,
    => false,
}

FormatSpecifier: FormatSpecifier = {
    <l:@L> <value:ident> <r:@R> =>? {
        match value {
            "u" => Ok(FormatSpecifier::Unsigned),
            "d" => Ok(FormatSpecifier::Signed),
            "x" => Ok(FormatSpecifier::Hex(CasingStyle::Any)),
            "X" => Ok(FormatSpecifier::Hex(CasingStyle::Upper)),
            _ => Err(ParseError::User {
                error: ParserError::from(ExprError::InvalidFormatSpecifier { span: span!(source_id, l, r) })
            }),
        }
    },

    => FormatSpecifier::Unsigned
}

Precision: u8 = {
    <l:@L> <n:number> <r:@R> =>? {
        u8::try_from(n).map_err(|_| ParseError::User {
            error: ParserError::from(ExprError::InvalidNumericPrecision { span: span!(source_id, l, r) })
        })
    },
    <error:ERROR> =>? Err(ParseError::User { error: ParserError::from(error) }),
}

Ident: Symbol = {
    ident => Symbol::intern(<>),
}

String: Span<&'input str> = {
    <l:@L> <raw:raw> <r:@R> => Span::new(span!(source_id, l, r), raw),
}
